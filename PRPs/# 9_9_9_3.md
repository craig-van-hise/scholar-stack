
# PRP: Polish Taxonomy Logic (Stopword Cleanup)

**Context:**
We have successfully refactored `src/2_cluster_taxonomy.py` to use structured JSON output. However, test logs indicate that category names are occasionally being truncated awkwardly (e.g., ending in "and") due to a strict word-count slice.

**Objective:**
Refine the category name cleaning logic to handle trailing stopwords gracefully while maintaining brevity.

**Target File:** `src/2_cluster_taxonomy.py`

## ðŸ› ï¸ Engineering Requirements

### 1. New Dependency

* Ensure `re` (regex) is imported at the top of the file (it likely already is, but verify).

### 2. Update Cleaning Logic

In the `cluster_and_categorize` function, inside the loop where `local_map` is populated:

**Locate this current logic:**

```python
# Enforce the "Max 3 Words" rule in code just in case
cat_clean = " ".join(item['category_name'].split()[:4])

```

**Replace it with this Robust Logic:**

```python
# 1. Take the full name from the LLM (trust the schema constraint first)
cat_raw = item['category_name'].strip()

# 2. Safety Truncate: Only chop if it's excessively long (> 6 words), not 4.
# This prevents cutting off meaningful modifiers like "Measurements".
words = cat_raw.split()
if len(words) > 6:
    cat_raw = " ".join(words[:6])

# 3. Stopword Cleanup: Remove trailing connectors that might have been exposed by truncation
# Regex targets: and, or, of, the, for, in, on, with, to
cat_clean = re.sub(r'\s+(and|or|of|the|for|in|on|with|to)$', '', cat_raw, flags=re.IGNORECASE).strip()

local_map[item['id']] = cat_clean

```

### 3. Verification

* Ensure the variable `cat_clean` is the one assigned to `local_map[item['id']]`.
* Ensure no syntax errors are introduced by the regex string.

## âœ… Definition of Done

1. **Logic Update:** The crude `[:4]` slice is replaced by a smarter length check (`>6`).
2. **Stopword Safety:** A category like "Crosstalk Cancellation Implementation and" is automatically cleaned to "Crosstalk Cancellation Implementation".
3. **Stability:** The script runs without regex compilation errors.